斐波那契数列Fibonacci sequence：又称黄金分割数列，古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，
            假如兔子都不死，问每个月的兔子总数为多少

n皇后问题：在8*8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法
    回溯法（探索与回溯法）：一种选优搜索法，又称试探法。利用试探性的方法，在包含问题所有解的解空间树中，将可能的结果搜索一遍，
    从而获得满足条件的解。搜索过程采用深度遍历策略，并随时判定结点是否满足条件要求，满足要求就继续向下搜索，若不满足要求则回溯到上一层，
    这种解决问题的方法称为回溯法

汉诺塔：移动大小盘子问题，当有n个盘子时，需要移动2^n - 1次
    递归的经典问题，问题详细就不多说了。
    求解：问题分解：
    (1) 将A上的N-1个盘移动到B上
    (2) 将A上的1个最大盘子移动到C上
    (3) 将B上的N-1个盘再移动到C上
    以上即显示了递归思想：将父问题分解为2个子问题
    Hanoi(1) = 1
    Hanoi(n) = 2*Hanoi(n-1) + 1； 其中1：盘n由A–>C的一次操作

    不使用递归实现：https://blog.csdn.net/weixin_42636076/article/details/81031580?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

动态规划---最大子序和问题 (LeetCode 53)：
    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和

prim算法：

谁是窃贼：
    公安人员审问四名窃贼嫌疑犯。已知，这四人当中仅有一名是窃贼，还知道这四人中每人要么是诚实的，要么总是说谎。在回答公安人员的问题中：
        甲说：“乙没有偷，是丁偷的。”
        乙说：“我没有偷，是丙偷的。”
        丙说：“甲没有偷，是乙偷的。”
        丁说：“我没有偷”
    请根据这四人的谈话判断谁是盗窃者

贪心算法：又称贪婪算法(Greedy Algorithm)，是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优解出发来考虑，它所做出的仅是在某种意义上的局部最优解。
    它是一种分阶段的工作，在每一个阶段，可以认为所做决定是最好的，而不考虑将来的后果。这种“眼下能够拿到的就拿”的策略是这类算法名称的来源
    贪心策略适用的前提是：局部最优策略能导致产生全局最优解。也就是当算法终止的时候，局部最优等于全局最优

反转字符串：@leetcodecn.digui.实现反转字符串的方式
    1.递归反转字符串
    2.递归反转字节数组
    3.for循环反转字节数组

Data structure and Algorithm in Java
https://blog.csdn.net/qq_39147389/article/details/82252924
分治法：

倒水问题：
    1.现在有3L，4L的杯子，无限多的水，要求用这两个容器倒出5L的水，如何求解? @pollwater.MyWater

二分查找目标值：二分法只适用于有序的数据 @binary.Find

排序：https://www.cnblogs.com/guoyaohua/p/8600214.html
    冒泡排序（Bubble Sort）：最佳情况：T(n) = O(n)    最差情况：T(n) = O(n^2)  平均情况：T(n) = O(n^2)
        比较相邻的元素。如果第一个比第二个大，就交换它们两个；
        对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
        针对所有的元素重复以上的步骤，除了最后一个；
        重复步骤1~3，直到排序完成。

    选择排序（Selection Sort）：最佳情况：T(n) = O(n^2)  最差情况：T(n) = O(n^2)  平均情况：T(n) = O(n^2)
       首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
       以此类推，直到所有元素均排序完毕

    插入排序（Insertion Sort）：最佳情况：T(n) = O(n)   最坏情况：T(n) = O(n2)   平均情况：T(n) = O(n2)
        假定n是数组的长度，
        首先假设第一个元素被放置在正确的位置上，这样仅需从1-n-1范围内对剩余元素进行排序。对于每次遍历，从0-i-1范围内的元素已经被排好序，
        每次遍历的任务是：通过扫描前面已排序的子列表，将位置i处的元素定位到从0到i的子列表之内的正确的位置上。
        将arr[i]复制为一个名为target的临时元素。
        向下扫描列表，比较这个目标值target与arr[i-1]、arr[i-2]的大小，依次类推。
        这个比较过程在小于或等于目标值的第一个元素(arr[j])处停止，或者在列表开始处停止（j=0）。
        在arr[i]小于前面任何已排序元素时，后一个条件（j=0）为真，
        因此，这个元素会占用新排序子列表的第一个位置。
        在扫描期间，大于目标值target的每个元素都会向右滑动一个位置（arr[j]=arr[j-1]）。
        一旦确定了正确位置j，
        目标值target（即原始的arr[i]）就会被复制到这个位置。
        与选择排序不同的是，插入排序将数据向右滑动，并且不会执行交换。

    希尔排序（缩小增量排序）：最佳情况：T(n) = O(nlog2 n)  最坏情况：T(n) = O(nlog2 n)  平均情况：T(n) =O(nlog2 n)
        先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：
            选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
            按增量序列个数k，对序列进行k 趟排序；
            每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

    归并排序：最佳情况：T(n) = O(n)  最差情况：T(n) = O(nlogn)  平均情况：T(n) = O(nlogn)


最大公约数和最小公倍数：两个自然数的最大公约数与它们的最小公倍数的乘积等于这两个数的乘积
    质因数分解法：
        把每个数分别分解质因数，再把各数中的全部公有质因数提取出来连乘，所得的积就是这几个数的最大公约数
            例如：求24和60的最大公约数，先分解质因数，得24=2×2×2×3，60=2×2×3×5，24与60的全部公有的质因数是2、2、3，它们的积是2×2×3=12，所以，（24，60）=12
        把几个数先分别分解质因数，再把各数中的全部公有的质因数和独有的质因数提取出来连乘，所得的积就是这几个数的最小公倍数
            例如：求6和15的最小公倍数。先分解质因数，得6=2×3，15=3×5，6和15的全部公有的质因数是3，6独有质因数是2，15独有的质因数是5，2×3×5=30，
                 30里面包含6的全部质因数2和3，还包含了15的全部质因数3和5，且30是6和15的公倍数中最小的一个，所以[6，15]=30

    短除法：
        短除法求最大公约数，先用这几个数的公约数连续去除，一直除到所有的商互质为止，然后把所有的除数连乘起来，所得的积就是这几个数的最大公约数
        求最大公因数便乘一边，求最小公倍数便乘一圈。
        短除法的本质就是质因数分解法，只是将质因数分解用短除符号来进行
        短除符号就是除号倒过来。短除就是在除法中写除数的地方写两个数共有的质因数，然后落下两个数被公有质因数整除的商，之后再除，以此类推，直到结果互质为止（两个数互质）。
        而在用短除计算多个数时，对其中任意两个数存在的因数都要算出，其它没有这个因数的数则原样落下。直到剩下每两个都是互质关系。
        无论是短除法，还是分解质因数法，在质因数较大时，都会觉得困难。这时就需要用新的方法

    辗转相除法：求两个自然数的最大公约数的一种方法，也叫欧几里德算法
        377 ÷ 319 =1...58
        319 ÷ 58  =5...29
        58  ÷ 29  =2   ∴（319，377）=29
        用辗转相除法求几个数的最大公约数，可以先求出其中任意两个数的最大公约数，再求这个最大公约数与第三个数的最大公约数，依次求下去，直到最后一个数为止。
        最后所得的那个最大公约数，就是所有这些数的最大公约数

    更相减损法：
        第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。
        第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。
        则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数
        其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。所以更相减损法也叫等值算法。

取一个整数a从右端开始的4～7位：four-eleven
    Math.floor() 向下取整，即小于这个数的最大的那个整数
    Math.ceil() 向上取整，即大于这个数的最小的那个整数
    Math.rint() 返回最接近该值的那个整数
    Math.round() 四舍五入   Math.round(x) = Math.floor(x + 0.5)


