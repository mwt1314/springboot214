jdk1.8 java.util.ArrayList源码分析：

1.单列各个集合底层数据结构和基本性质
一.List集合：（有序，元素可以重复）
1.ArrayList集合：底层数据结构是数组，查找快，增删慢
                线程不安全，效率高
                底层数组的扩容规则：3/2倍

2.Vector集合：底层数据结构是数组，查询快，增删慢
             线程安全synchronized，效率低
             底层数组的扩容规则：当前容量 + 增量

3.LinkedList集合：底层数据结构是双向链表，查询慢，增删快
                 线程不安全，效率高

public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable{

    int DEFAULT_CAPACITY = 10;
    Object[] EMPTY_ELEMENTDATA = {};
    Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    //*********底层是用数组来存放元素的，扩容方式：3/2倍
    //底层数组决定了ArrayList是有序的，
    transient Object[] elementData;
    int size;   //*********实际大小

    protected transient int modCount = 0;   //记录该ArrayList被修改的次数，用于fast-fail快速失败机制，该属性在AbstractList中被定义


    //默认构造器，初始化elementData={}
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    //指定底层数组的默认大小
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity);
        }
    }

    //ArrayList新增数据的方法 ，元素可以为null
    //1.由于底层是用数组来存放元素的，所以需要判断是否对数组进行扩容
    //2.更新modCount++
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }

    //在指定位置插入元素
    //1.下标校验 [0,size]就是合法的下标
    //2.是否考虑需要扩容
    //3.index后元素全部后移
    //4.在index位置插入元素
    //5.更新size
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        ensureCapacityInternal(size + 1);
        System.arraycopy(elementData, index, elementData, index + 1, size - index);
        elementData[index] = element;
        size++;
    }

    //将底层数组缩放到size大小，因为每次扩容后数组默认被null填充，该方法就是去掉null
    public void trimToSize() {
        modCount++;
        if (size < elementData.length) {
            elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size);
        }
    }

    //判断该list是否包含指定元素
    public boolean contains(Object o) {
        return indexOf(o) >= 0;
    }

    //返回该list指定元素的下标，如果有重复的就返回从左到右第一个
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i < size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }

    //拷贝一个ArrayList对象
    public Object clone() {
        try {
            ArrayList<?> v = (ArrayList<?>) super.clone();
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            throw new InternalError(e);
        }
    }

    public E get(int index) {
        rangeCheck(index);
        return elementData(index);
    }

    public E set(int index, E element) {
        rangeCheck(index);
        E oldValue = elementData(index);
        elementData[index] = element;
        return oldValue;
    }

    //移除指定位置的元素
    public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)   //数据前移
            System.arraycopy(elementData, index+1, elementData, index, numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }


    private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }

    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;   //当前数组的容量
        int newCapacity = oldCapacity + (oldCapacity >> 1); //新容量= 3/2倍的老容量
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);  //将老数组中的元素全部复制到新数组中
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;
    }


}

