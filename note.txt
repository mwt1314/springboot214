1.@SpringBootApplication注解依赖
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>
cas:CompareAndSwap



设计模式：
    1.单例模式：
    2.模板方法模式：抽取公共实现，剥离单独实现
    3.建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
    4.观察者模式：     java.util.Observer
                    java.util.Observable
    5.代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介
        主要优点有：
            代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
            代理对象可以扩展目标对象的功能；
            代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；
        主要缺点是：
            在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
            增加了系统的复杂度

        静态代理：编译期间手动生成代理对象
        动态代理：
            JDK动态代理：在程序运行时JVM才为被代理对象生成代理对象
                        限制：被代理的对象必须实现一个或多个接口，若想代理没有实现接口的类，就需要使用Cglib实现
            Cglib动态代理（子类代理）：在内存中构建一个子类对象从而实现对目标对象功能的扩展
    6.适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
            适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些
            该模式的主要优点如下。
                客户端通过适配器可以透明地调用目标接口。
                复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
                将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
            其缺点是：对类适配器来说，更换适配器的实现过程比较复杂

            适配器模式（Adapter）包含以下主要角色。
                目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
                适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
                适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。
    7.原型模式：原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是选型模式的用意
            有两种表现形式：（1）简单形式、（2）登记形式，这两种表现形式仅仅是原型模式的不同实现

            原型模式分三个角色，抽象原型类，具体原型类，客户类。
                抽象原型类（prototype）:它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是接口，抽象类甚至是一个具体的实现类。
                具体原型类（concretePrototype）：它实现了抽象原型类中声明的克隆方法，在克隆方法中返回一个自己的克隆对象。
                客户类（Client）：在客户类中，使用原型对象只需要通过工厂方式创建或者直接NEW（实例化一个）原型对象，然后通过原型对象的克隆方法就能获得多个相同的对象。由于客户端是针对抽象原型对象编程的所以还可以可以很方便的换成不同类型的原型对象

            浅克隆：如果原型对象的成员变量是值类型（八大基本类型，byte,short,int,long,char,double,float,boolean）.那么就直接复制，如果是复杂的类型（枚举，String,对象）就只复制对应的内存地址
                    在换个说法，就是复杂类型的成员变量（String,枚举，啥的）用的是一个。修改了克隆对象的原型对象也会变。他们是共用的。而值类型不是共用的
            深克隆：全部复制，然后各自独立。你修改克隆对象对于原型对象没有丝毫影响
    8.桥接模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度
    9.装饰者模式：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式
        装饰（Decorator）模式的主要优点有：
            采用装饰模式扩展对象的功能比采用继承方式更加灵活。
            可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。
        其主要缺点是：
            装饰模式增加了许多子类，如果过度使用会使程序变得很复杂
        装饰模式主要包含以下角色。
            抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
            具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。
            抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
            具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任
    10.命令模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理
        主要优点如下。
            降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
            增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
            可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
            方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。
        其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。
    11.
    12.

