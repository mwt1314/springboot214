

    public ThreadPoolExecutor(int corePoolSize,     //核心线程数量
                              int maximumPoolSize,  //最大线程数量
                              long keepAliveTime,   //线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime
                              TimeUnit unit,        //时间级别
                              BlockingQueue<Runnable> workQueue,    //等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列
                              ThreadFactory threadFactory,  //它是ThreadFactory类型的变量，用来创建新线程
                              RejectedExecutionHandler handler) {   //RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务

    }


    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    private static final int COUNT_BITS = 29; //常量
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1; //  0001 1111 1111 1111 1111 1111 1111 1111

    // runState is stored in the high-order bits
    //-1的补码为11111111111111111111111111111111，左移29位就是11100000000000000000000000000000
    //2的补码为10，左移29位就是01000000000000000000000000000000
    private static final int RUNNING    = -1 << COUNT_BITS;     // 高3位为111， 低29位为0  该状态的线程池会接收新任务，也会处理在阻塞队列中等待处理的任务
    private static final int SHUTDOWN   =  0 << COUNT_BITS;     // 高3位为000， 低29位为0  该状态的线程池不会再接收新任务，但还会处理已经提交到阻塞队列中等待处理的任务
    private static final int STOP       =  1 << COUNT_BITS;     // 高3位为001， 低29位为0  该状态的线程池不会再接收新任务，不会处理在阻塞队列中等待的任务，而且还会中断正在运行的任务
    private static final int TIDYING    =  2 << COUNT_BITS;     // 高3位为010， 低29位为0  所有任务都被终止了，workerCount为0，为此状态时还将调用terminated()方法
    private static final int TERMINATED =  3 << COUNT_BITS;     // 高3位为100， 低29位为0  terminated()方法调用完成后变成此状态


    // Packing and unpacking ctl
    private static int runStateOf(int c)     { return c & ~CAPACITY; }  // c & 高3位为1，低29位为0的~CAPACITY，用于获取高3位保存的线程池状态
    private static int workerCountOf(int c)  { return c & CAPACITY; }   // c & 高3位为0，低29位为1的CAPACITY，用于获取低29位的线程数量
    private static int ctlOf(int rs, int wc) { return rs | wc; }        // 参数rs表示runState，参数wc表示workerCount，即根据runState和workerCount打包合并成ctl

    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get(); // 初始状态下，c=
        if (workerCountOf(c) < corePoolSize) {RUNNING
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }





