java不能直接访问操作系统底层，而是通过本地方法来访问。Unsafe类提供了硬件级别的原子操作

public native long allocateMemory(long l);      //分配内存
public native long reallocateMemory(long l, long l1);   //扩充内存
public native void freeMemory(long l);  //释放内存

public native long objectFieldOffset(Field var1);   //指定field的偏移量

public native long staticFieldOffset(Field var1);

public native Object staticFieldBase(Field var1);

//获取给定数组中第一个元素的偏移地址
public native int arrayBaseOffset(Class arrayClass);

// 获取用户给定数组寻址的换算因子，也就是数组中元素的增量地址
public native int arrayIndexScale(Class<?> var1);   //将arrayBaseOffset与arrayIndexScale配合使用，可以定位数组中每个元素在内存中的位置。

//设置obj对象中offset偏移地址对应的整型field的值为指定值。这是一个有序或者有延迟的<code>putIntVolatile</cdoe>方法，并且不保证值的改变被其他线程立即看到。只有在field被<code>volatile</code>修饰并且期望被意外修改的时候使用才有用。
public native void putOrderedInt(Object obj, long offset, int value);

//设置obj对象中offset偏移地址对应的整型field的值为指定值。支持volatile store语义
public native void putIntVolatile(Object obj, long offset, int value);

//释放被park创建的在一个线程上的阻塞
public native void unpark(Thread thread);

//阻塞一个线程直到unpark出现、线程被中断或者timeout时间到期。如果一个unpark调用已经出现了，这里只计数。timeout为0表示永不过期
public native void park(boolean isAbsolute, long time);



public class AtomicIntegerArray implements java.io.Serializable {

    private static final Unsafe unsafe = Unsafe.getUnsafe();
    //返回指定类型数组的第一个元素地址相对于数组起始地址的偏移
    private static final int base = unsafe.arrayBaseOffset(int[].class);
    private static final int shift;
    private final int[] array;

    static {
        //返回指定类型数组的元素占用的字节数
        int scale = unsafe.arrayIndexScale(int[].class);
        if ((scale & (scale - 1)) != 0)
            throw new Error("data type scale not a power of two");
        //Integer.numberOfLeadingZeros(scale);  //将scale转换为2进制，然后从左往右数遇到第一个非1的连续0的个数
        shift = 31 - Integer.numberOfLeadingZeros(scale);
    }

    private long checkedByteOffset(int i) {
        if (i < 0 || i >= array.length)
            throw new IndexOutOfBoundsException("index " + i);
        return byteOffset(i);
    }

    //返回数组中索引为i的元素相对于数组起始位置的偏移
    private static long byteOffset(int i) {
        //等价于i * scale + base   <===    2 ^ shift = scale   <===    1向左移动shift位等于scale
        return ((long) i << shift) + base;
    }

}







