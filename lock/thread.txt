线程状态：
NEW（新建）：新创建了一个线程对象，但还没有调用start()方法
RUNNABLE（可运行）：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”，包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程可能正在运行，也可能正在等待系统资源，
                    如等待CPU为它分配时间片，如等待网络IO读取数据获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）
BLOCKED（阻塞）：表示线程阻塞于锁。当一个线程要进入synchronized语句块/方法时，如果没有获取到锁（waiting to enter monitor），会变成BLOCKED，直到另一个线程走完临界区或发生了相应锁对象的wait()操作后，它才有机会去争夺进入临界区的权利
                处于BLOCKED状态的线程，即使对其调用 thread.interrupt()也无法改变其阻塞状态，因为interrupt()方法只是设置线程的中断状态，即做一个标记，不能唤醒处于阻塞状态的线程
                ReentrantLock.lock()操作后进入的是WAITING状态，其内部调用的是LockSupport.park()方法
WAITING（无限期等待）：处于这种状态的线程不会被CPU分配时间片，它们要等待被显式地唤醒，否则会处于无限期等待的状态
                    这种状态通常是指一个线程拥有对象锁后进入到相应的代码区域后，调用相应的“锁对象”的wait()方法操作后该线程会进入WAITING状态
                    调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内
    以下方法会让线程陷入无限期等待状态：
      obj.wait();
      thread.join();
      LockSupport.park();  --  驻留
      注意：
      LockSupport.park(Object blocker) 会挂起当前线程，参数blocker是用于设置当前线程的“volatile Object parkBlocker 成员变量”
      parkBlocker 是用于记录线程是被谁阻塞的，可以通过LockSupport.getBlocker()获取到阻塞的对象，用于监控和分析线程用的。

      “阻塞”与“等待”的区别：
      （1）阻塞：当一个线程试图获取对象锁（非java.util.concurrent库中的锁，即synchronized），而该锁被其他线程持有，则该线程进入阻塞状态。它的特点是使用简单，由JVM调度器来决定唤醒自己，而不需要由另一个线程来显式唤醒自己，不响应中断。
      （2）等待：当一个线程等待另一个线程通知调度器一个条件时，该线程进入等待状态，是在等待一段时间 或者 唤醒动作的发生，进入“等待”状态是主动的
      如主动调用Object.wait()，如无法获取到ReentraantLock，主动调用LockSupport.park()，如主线程主动调用 subThread.join()，让主线程等待子线程执行完毕再执行
      离开“等待”状态是因为其它线程发生了唤醒动作或者到达了等待时间

TIMED_WAITING（超时等待）：处于这种状态的线程也不会被分配CPU执行时间，不过无需等待被其它线程显示的唤醒，在一定时间之后它们会由系统自动的唤醒
    以下方法会让线程进入TIMED_WAITING限期等待状态：
      thread.sleep(timeout);
      obj.wait(timeout);
      thread.join(timeout);
      LockSupport.parkUntil(deadline);  --  驻留
      LockSupport.parkNanos(timeout);

TERMINATED（结束）：RUNNABLE线程run方法走完或者发生异常时


public class Object {
    public final native void notify();
    public final native void notifyAll();
    public final native void wait(long timeout) throws InterruptedException;

    //当前线程调用“锁对象”的wait()方法，当前线程释放对象锁，进入等待队列WAITING
    //调用obj的wait()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内
    public final void wait() throws InterruptedException {
        wait(0);
    }

}

thread.join(); //当前线程里调用其它线程t的join方法，当前线程等待thread线程执行完成才会执行，当前线程会进入WAITING，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程进入就绪状态
thread.join(timeout); //当前线程等待thread线程执行完成才会执行，最多等待time时间，当前线程会进入TIME_WAITING

thread.yield();当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态

thread.sleep(timeout);不会释放对象锁,thread会进入TIMED_WAITING，睡眠时间结束后进入就绪状态，当前线程会进入TIME_WAITING

obj.wait();使得当前正持有该对象的锁的线程等待（即暂停），并释放对象锁，以便其它线程能够获取该对象的锁，当前线程会进入WAITING
obj.wait(timeout);指定等待时间，如果指定时间内没有notify或者notifyAll唤醒它，则时间到了后自动唤醒，如果时间还没到但是有notify或者notifyAll唤醒它，则会提前唤醒，当前线程会进入TIME_WAITING

obj.notify();唤醒一个正在等待该对象锁的线程（即处于wait状态的线程），具体哪一个随机
obj.notifyAll();唤醒所有正在等待该对象锁的线程（即处于wait状态的线程)

锁池：假设线程A已经拥有对象锁，线程B、C想要获取锁就会被阻塞，进入一个地方去等待锁的等待，这个地方就是该对象的锁池；
等待池：假设线程A调用某个对象的wait方法，线程A就会释放该对象锁，同时线程A进入该对象的等待池中，进入等待池中的线程不会去竞争该对象的锁。

notify和notifyAll的区别：
1、notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；
2、notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；

中断：Java中断机制是一种协作机制，通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断
interrupt()中断：将线程的中断标志位置位
如果线程sleep()、wait()、join()等处于阻塞状态，那么线程会定时检查中断状态位如果发现中断状态位为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后立即将线程的中断状态位清除，即重新设置为false。抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。
如果线程正在运行、争用synchronized、lock()等，那么是不可中断的，他们会忽略。
可以通过以下三种方式来判断中断：
1)isInterrupted()此方法只会读取线程的中断标志位，并不会重置。
2)interrupted()此方法读取线程的中断标志位，并会重置。
3)throw InterruptException抛出该异常的同时，会重置中断标志位。

thread.interrupt(); //实例方法  如果正在运行wait()，sleep()，join()这三个方法阻塞了线程，那么将会使得线程抛出InterruptedException异常，这是一个中断阻塞的过程。如果是其它的正在运行的状态，那么将不会有任何影响，也不会中断线程，或者抛出异常，只会会打上一个中断线程的标志，是否中断线程，将由程序控制。
boolean interrupted = Thread.interrupted(); //静态方法，返回当前线程是否有中断标志并清除当前线程的中断标志：就是如果当前线程已中断，第一次调用这个方法的返回值是true，第二次调用这个方法的返回值为false，因为调用方法时，会清除它的中断标志
boolean interrupted = thread.isInterrupted(); //实例方法    返回该线程是否有中断标志

中断的使用场景有以下几个：
    点击某个桌面应用中的取消按钮时；
    某个操作超过了一定的执行时间限制需要中止时；
    多个线程做相同的事情，只要一个线程成功其它线程都可以取消时；
    一组线程中的一个或多个出现错误导致整组都无法继续时；
    当一个应用或服务需要停止时。





